package com.example.nutriengine.nutrienginemain.Utility;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class DietPlanParser {

    private DietPlanParser() {
    }

    /**
     * Parses the raw diet plan text generated by an AI model into a structured Map.
     * The structure includes sections for introductory notes, daily meal plans,
     * summarized ingredients, important notes, and a closing note.
     *
     * @param rawText The raw, multi-line diet plan string from the AI,
     * expected to follow a specific markdown-like format.
     * @return A Map representing the structured diet plan data.
     * Returns an empty Map if the rawText is null or empty,
     * or if no recognizable sections are found.
     */
    public static Map<String, Object> parseDietPlanResponse(String rawText) {
        Map<String, Object> sections = new HashMap<>();

        if (rawText == null || rawText.trim().isEmpty()) {
            return sections; // Return empty map for null or empty input
        }

        // 1. Extract the initial general notes (before "Day 1")
        // Pattern.DOTALL allows . to match newlines
        Pattern generalNotesPattern = Pattern.compile("^(.*?)(?=\\n\\n\\*\\*Day 1\\*\\*)", Pattern.DOTALL);
        Matcher generalNotesMatcher = generalNotesPattern.matcher(rawText);
        if (generalNotesMatcher.find()) {
            sections.put("introNotes", generalNotesMatcher.group(1).trim().replaceAll("\\n\\n", "\n"));
        } else {
            // If no clear "Day 1" header, treat the beginning as intro notes up to the first known section
            Pattern fallbackIntroPattern = Pattern.compile("^(.*?)(?=\\n\\n\\*\\*Summarized Ingredients List\\*\\*|\\n\\n\\*\\*Important Notes\\*\\*|$)", Pattern.DOTALL);
            Matcher fallbackIntroMatcher = fallbackIntroPattern.matcher(rawText);
            if (fallbackIntroMatcher.find()) {
                sections.put("introNotes", fallbackIntroMatcher.group(1).trim().replaceAll("\\n\\n", "\n"));
            } else {
                sections.put("introNotes", "No specific introductory notes found.");
            }
        }

        // 2. Extract each day's plan
        Pattern dayPattern = Pattern.compile("\\*\\*Day (\\d+)\\*\\*([\\s\\S]*?)(?=\\n\\n\\*\\*Day \\d+\\*\\*|$)", Pattern.DOTALL);
        Matcher dayMatcher = dayPattern.matcher(rawText);

        while (dayMatcher.find()) {
            String dayNumber = dayMatcher.group(1);
            String dayContent = dayMatcher.group(2).trim();

            Map<String, String> meals = new HashMap<>();
            // Regex to capture Breakfast, Lunch, Snack, Dinner.
            // Using non-capturing group (?:...) for alternatives to avoid extra groups.
            // Using word boundary \b to ensure "Breakfast" is not part of a larger word.
            Pattern mealPattern = Pattern.compile("\\* \\*\\*(Breakfast|Lunch|Snack|Dinner):\\*\\*([\\s\\S]*?)(?=\\* \\*\\*(?:Breakfast|Lunch|Snack|Dinner):|\\n\\n|$)", Pattern.DOTALL);
            Matcher mealMatcher = mealPattern.matcher(dayContent);

            while (mealMatcher.find()) {
                String mealType = mealMatcher.group(1).toLowerCase(); // breakfast, lunch, snack, dinner
                String mealDescription = mealMatcher.group(2).trim();

                // Remove leading markdown list asterisk and space if present (e.g., "* ")
                if (mealDescription.startsWith("* ")) {
                    mealDescription = mealDescription.substring(2);
                }
                meals.put(mealType, mealDescription.trim());
            }
            sections.put("day" + dayNumber, meals);
        }

        // 3. Extract Summarized Ingredients List
        Pattern ingredientsPattern = Pattern.compile("\\*\\*Summarized Ingredients List:\\*\\*([\\s\\S]*?)(?=\\n\\n\\*\\*Important Notes:\\*\\*|$)", Pattern.DOTALL);
        Matcher ingredientsMatcher = ingredientsPattern.matcher(rawText);
        if (ingredientsMatcher.find()) {
            String rawIngredients = ingredientsMatcher.group(1).trim();
            Map<String, List<String>> ingredientCategories = new HashMap<>();

            // Pattern to find each category within the ingredients list
            // Looks for "**Category Name:**" then captures content until next category or end of section
            Pattern categoryPattern = Pattern.compile("\\* \\*\\*(.*?):\\*\\*([\\s\\S]*?)(?=(?:\\* \\*\\*.*?\\*\\*)|$)", Pattern.DOTALL);
            Matcher categoryMatcher = categoryPattern.matcher(rawIngredients);

            while (categoryMatcher.find()) {
                String categoryName = categoryMatcher.group(1).trim();
                List<String> items = new ArrayList<>();
                // Split by lines, trim each line, filter out empty lines, and remove leading markdown list asterisk
                Arrays.stream(categoryMatcher.group(2).split("\\n"))
                        .map(String::trim)
                        .filter(item -> !item.isEmpty())
                        .map(item -> item.startsWith("* ") ? item.substring(2) : item) // Remove leading asterisk
                        .forEach(items::add);
                ingredientCategories.put(categoryName.toLowerCase(), items);
            }
            sections.put("ingredients", ingredientCategories);
        }

        // 4. Extract Important Notes
        // Handles case where closing note might be missing or different
        Pattern notesPattern = Pattern.compile("\\*\\*Important Notes:\\*\\*([\\s\\S]*?)(?=\\n\\nEnjoy your delicious and healthy Indian vegetarian journey!|$)", Pattern.DOTALL);
        Matcher notesMatcher = notesPattern.matcher(rawText);
        if (notesMatcher.find()) {
            List<String> notes = new ArrayList<>();
            Arrays.stream(notesMatcher.group(1).trim().split("\\n"))
                    .map(String::trim)
                    .filter(line -> !line.isEmpty())
                    .map(line -> line.startsWith("* ") ? line.substring(2) : line) // Remove leading asterisk
                    .forEach(notes::add);
            sections.put("importantNotes", notes);
        }

        // 5. Extract Closing Note (if present and at the end)
        // This regex looks specifically for the closing phrase at the very end of the string.
        Pattern closingNotePattern = Pattern.compile("(Enjoy your delicious and healthy Indian vegetarian journey!)$", Pattern.DOTALL);
        Matcher closingNoteMatcher = closingNotePattern.matcher(rawText);
        if (closingNoteMatcher.find()) {
            sections.put("closingNote", closingNoteMatcher.group(1).trim());
        }

        return sections;
    }
}